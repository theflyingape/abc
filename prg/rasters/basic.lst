ca65 V2.13.2 - (C) Copyright 1998-2005 Ullrich von Bassewitz
Main file   : basic.s
Current file: basic.s

000000r 1               ;*********************************************************************
000000r 1               ; COMMODORE VIC 20 ABC PROGRAM STARTUP USING BASIC 2.0
000000r 1               ; written by Robert Hurst <robert@hurst-ri.us>
000000r 1               ; updated version: 20-Aug-2015
000000r 1               ;
000000r 1               	.fileopt author,	"Robert Hurst"
000000r 1                       .fileopt comment,	"ABC-SLIK startup"
000000r 1                       .fileopt compiler,	"6502 assembler (ca65)"
000000r 1               
000000r 1               	.include "abc.h"
000000r 2               ;***********************************************************************
000000r 2               ; VIC 20: Awesome Boot Cartridge
000000r 2               ;   written by Robert Hurst <robert@hurst-ri.us>
000000r 2               ;   updated version: 21-Oct-2015
000000r 2               ;
000000r 2               ; relevant VIC 20 symbols for your program's use or reference
000000r 2               ;
000000r 2               RNDSEED		= $8B		; -$8F: BASIC RND seed value
000000r 2               JIFFYH		= $A0		; jiffy clock high
000000r 2               JIFFYM		= $A1		; jiffy clock med
000000r 2               JIFFYL		= $A2		; jiffy clock low
000000r 2               DATANEXT	= $A6		; DATASETTE pointer (0-191)
000000r 2               KEYCHARS	= $C6		; number of characters in KEYBUF (0-10)
000000r 2               RVSFLAG		= $C7		; character reverse flag
000000r 2               ROWS		= $C8		; current screen row length (16-24)
000000r 2               CURSOR		= $CC		; cursor enable (0=flash)
000000r 2               CRSRCHAR	= $CE		; character under cursor
000000r 2               SCRNLINE	= $D1		; pointer to cursor's screen line
000000r 2               CRSRCOL		= $D3		; position of cursor on screen line
000000r 2               CRSR		= $D4		; programmed cursor (0=direct)
000000r 2               COLS		= $D5		; current screen line length (16-24)
000000r 2               CRSRROW		= $D6		; screen row where cursor is
000000r 2               INSERTS		= $D8		; # of INSERTs outstanding
000000r 2               LINKLINE	= $D9		; -$F0: screen line link table
000000r 2               SCRTEMP1	= $F1		; dummy screen link
000000r 2               SCRTEMP2	= $F2		; screen row marker
000000r 2               COLORLINE	= $F3		; pointer to cursor's color line
000000r 2               KEYBOARD	= $F5		; keyboard pointer
000000r 2               RECEIVE		= $F7		; serial receive pointer
000000r 2               TRANSMIT	= $F9		; serial transmit pointer
000000r 2               BASICTMP	= $FF		; BASIC storage
000000r 2               INPUT		= $0200		; -$0258: 89-character BASIC INPUT buffer
000000r 2               KEYBUF		= $0277		; -$0280: 10-character keyboard buffer
000000r 2               COLORCODE	= $0286		; current cursor color
000000r 2               CRSRCOLOR	= $0287		; color under cursor
000000r 2               SCRNPAGE	= $0288		; active screen memory page (unexpanded = $1E)
000000r 2               SHIFTMODE	= $0291		; 0=allow, 128=locked
000000r 2               SCROLLFLAG	= $0292		; auto scrolldown flag
000000r 2               TEMPA		= $030C		; temp storage for A register
000000r 2               TEMPX		= $030D		; temp storage for X register
000000r 2               TEMPY		= $030E		; temp storage for Y register
000000r 2               TEMPP		= $030F		; temp storage for P register
000000r 2               VECTORS		= $0310		; -$033B: VIC ROM jump vectors
000000r 2               DATASETTE	= $033C		; -$03FB: 192-byte tape input buffer
000000r 2               RAM0		= $0400		; -$0FFF: 3K expansion
000000r 2               RAM		= $1000		; -$1FFF: internal memory
000000r 2               RAM1		= $2000		; -$3FFF: 8K expansion
000000r 2               RAM2		= $4000		; -$5FFF: 8K expansion
000000r 2               RAM3		= $6000		; -$7FFF: 8K expansion
000000r 2               PET		= $8000		; -$8FFF: 4k character rom
000000r 2               MASK		= $8270		; ROM character $4D: Shift-N (/)
000000r 2               VIC		= $9000		; start of Video Interface Chip registers
000000r 2               CART		= $A000		; -$BFFF: 8K expansion
000000r 2               ; ****	VIC BASIC & KERNAL ROM	****
000000r 2               PRINT		= $CB1E		; print null-terminated string
000000r 2               PRINTUINT	= $DDCD		; print XA as unsigned integer
000000r 2               BASSFT		= $E467		; BASIC warm start
000000r 2               MACHINE		= $EDE4		; NTSC=$05, PAL=$0C
000000r 2               STOPKEY		= $F770		; check for STOP key pressed
000000r 2               RESET		= $FD22		; warm startup
000000r 2               VECTOR		= $FF8D		; read/set vectored I/O
000000r 2               RESTOR		= $FF8A		; restore default I/O vectors
000000r 2               SETMSG		= $FF90		; control KERNAL messages
000000r 2               SECOND		= $FF93		; send secondary address after LISTEN
000000r 2               TKSA		= $FF96		; send secondary address after TALK
000000r 2               MEMTOP		= $FF99		; read/set the top of memory
000000r 2               MEMBOT		= $FF9C		; read/set the bottom of memory
000000r 2               SCNKEY		= $FF9F		; scan keyboard
000000r 2               SETTMO		= $FFA2		; set timeout on serial bus
000000r 2               ACPTR		= $FFA5		; input byte from serial port
000000r 2               CIOUT		= $FFA8		; output byte to serial port
000000r 2               UNTLK		= $FFAB		; command serial bus device to UNTALK
000000r 2               UNLSN		= $FFAE		; command serial bus device to UNLISTEN
000000r 2               LISTEN		= $FFB1		; send LISTEN command
000000r 2               TALK		= $FFB4		; send TALK command
000000r 2               READST		= $FFB7		; read I/O status word
000000r 2               SETLFS		= $FFBA		; set logical, first and second addresses
000000r 2               SETNAM		= $FFBD		; set filename
000000r 2               OPEN		= $FFC0		; open a logical file
000000r 2               CLOSE		= $FFC3		; close a logical file
000000r 2               CHKIN		= $FFC6		; open channel for input
000000r 2               CHKOUT		= $FFC9		; open channel for output
000000r 2               CLRCHN		= $FFCC		; close input and out channels
000000r 2               CHRIN		= $FFCF		; input character from channel
000000r 2               CHROUT		= $FFD2		; output character to channel
000000r 2               LOAD		= $FFD5		; load RAM from a device
000000r 2               SAVE		= $FFD8		; save RAM to device
000000r 2               SETTIM		= $FFDB		; set real time clock
000000r 2               RDTIM		= $FFDE		; read real time clock
000000r 2               STOP		= $FFE1		; scan STOP key
000000r 2               GETIN		= $FFE4		; get a character from keyboard queue
000000r 2               CLALL		= $FFE7		; close all channels and files
000000r 2               UDTIM		= $FFEA		; increment real time clock
000000r 2               SCREEN		= $FFED		; return X,Y organization of screen
000000r 2               PLOT		= $FFF0		; read/set X,Y cursor position
000000r 2               IOBASE		= $FFF3		; returns base address of I/O devices
000000r 2               
000000r 2               
000000r 1               
000000r 1               ;*********************************************************************
000000r 1               ; Commodore BASIC 2.0 program
000000r 1               ;
000000r 1               ; LOAD "PROGRAM",8
000000r 1               ; RUN
000000r 1               ;
000000r 1               	.segment "CODE"
000000r 1               
000000r 1  rr rr        	.word	RUN		; load address
000002r 1  rr rr        RUN:	.word	@end		; next line link
000004r 1  DF 07        	.word	2015		; line number
000006r 1  9E           	.byte	$9E		; BASIC token: SYS
000007r 1  rr           	.byte	<(MAIN / 1000 .mod 10) + $30
000008r 1  rr           	.byte	<(MAIN / 100 .mod 10) + $30
000009r 1  rr           	.byte	<(MAIN / 10 .mod 10) + $30
00000Ar 1  rr           	.byte	<(MAIN / 1 .mod 10) + $30
00000Br 1  00           	.byte	0		; end of line
00000Cr 1  00 00        @end:	.word	0		; end of program
00000Er 1               
00000Er 1               
00000Er 1               ;*********************************************************************
00000Er 1               ; Starting entry point for this program
00000Er 1               ;
00000Er 1               MAIN:
00000Er 1  AE FC FF     	ldx $FFFC
000011r 1  AC FD FF     	ldy $FFFD
000014r 1  8E 18 03     	stx $0318
000017r 1  8C 19 03     	sty $0319		; enable RESTORE key as RESET
00001Ar 1  AD E4 ED     	lda MACHINE
00001Dr 1  C9 05        	cmp #5
00001Fr 1  F0 07        	beq NTSC
000021r 1  C9 0C        	cmp #12
000023r 1  F0 0E        	beq PAL
000025r 1  4C 22 FD     READY:	jmp RESET		; not a VIC?
000028r 1               	;
000028r 1               	; NTSC setup
000028r 1  A2 43        NTSC:	ldx #<@NTSC		; load the timer low-byte latches
00002Ar 1  8E 26 91     	stx $9126
00002Dr 1  A2 42        	ldx #>@NTSC
00002Fr 1  A9 5D        	lda #117 - 24		; raster line 234/235 ($75)
000031r 1  D0 0B        	bne IRQSYNC
000033r 1               @NTSC = (261 * 65 - 2)		; $4243
000033r 1               	;
000033r 1               	; PAL setup
000033r 1  A2 86        PAL:	ldx #<@PAL		; load the timer low-byte latches
000035r 1  8E 26 91     	stx $9126
000038r 1  A2 56        	ldx #>@PAL
00003Ar 1  A9 6A        	lda #130 - 24		; raster line 260/261 ($82)
00003Cr 1  D0 00        	bne IRQSYNC
00003Er 1               @PAL = (312 * 71 - 2)		; $5686
00003Er 1               	;
00003Er 1               IRQSYNC:
00003Er 1  CD 04 90     	cmp VIC + 4
000041r 1  D0 FB        	bne IRQSYNC
000043r 1  8E 25 91     	stx $9125		; load T1 latch high
000046r 1               				; and transfer both bytes to T1 counter
000046r 1               
000046r 1               	; setup my background processing
000046r 1               	.global MYIRQ
000046r 1  78           	SEI
000047r 1  A2 rr        	LDX #<MYIRQ
000049r 1  A0 rr        	LDY #>MYIRQ
00004Br 1  8E 14 03     	STX $0314
00004Er 1  8C 15 03     	STY $0315
000051r 1  58           	CLI
000052r 1               
000052r 1               
000052r 1               ;*********************************************************************
000052r 1               ; Now that all the VIC startup initialization stuff is completed,
000052r 1               ; you can append one-time startup code/data here, i.e., like a splash
000052r 1               ; title screen.  Then, you must jump to your CODE segment, linked
000052r 1               ; outside of VIC's internal RAM address space ...
000052r 1               ;
000052r 1               RUNONCE:
000052r 1               @loop:
000052r 1  AD 8D 02     	lda $028D
000055r 1  29 02        	and #2			; got C= key?
000057r 1  D0 11        	bne @go
000059r 1  A0 00        	ldy #0
00005Br 1  8C 13 91     	sty $9113
00005Er 1  A9 FF        	lda #$FF
000060r 1  8D 22 91     	sta $9122
000063r 1  AD 11 91     	lda $9111
000066r 1  29 20        	and #$20		; got joystick FIRE ?
000068r 1  D0 E8        	bne @loop
00006Ar 1               @go:
00006Ar 1  60           	rts
00006Br 1               
00006Br 1               
00006Br 1               MYIRQ:
00006Br 1  A9 00        	lda #0
00006Dr 1  A2 08        	ldx #8
00006Fr 1  8E 0F 90     	stx VIC + $0f
000072r 1  AC 04 90     	ldy VIC + 4
000075r 1  C8           	iny
000076r 1  C8           	iny
000077r 1  CC 04 90     @ns:	cpy VIC + 4
00007Ar 1  D0 FB        	bne @ns
00007Cr 1  8D 0F 90     	sta VIC + $0f
00007Fr 1               
00007Fr 1               @cycle:
00007Fr 1  EE 0F 90     	inc VIC + $0f
000082r 1  D0 FB        	bne @cycle
000084r 1               
000084r 1  8E 0F 90     	stx VIC + $0f
000087r 1  AD 04 90     	lda VIC + 4
00008Ar 1  18           	clc
00008Br 1  69 04        	adc #4
00008Dr 1  CD 04 90     @vs:	cmp VIC + 4
000090r 1  D0 FB        	bne @vs
000092r 1               
000092r 1  A9 1B        	lda #27
000094r 1  8D 0F 90     	sta VIC + $0f		; white screen / cyan border
000097r 1  4C BF EA     	jmp $eabf
00009Ar 1               
00009Ar 1               
00009Ar 1               ;*********************************************************************
00009Ar 1               ; VIC user-definable characters
00009Ar 1               ;
00009Ar 1               ; If < 64 will be used for the software sprite stack, the remaining
00009Ar 1               ; unused characters can be used for other custom graphics, beginning
00009Ar 1               ; at $1C00 where "@", "A", "B", ... characters can be redefined.
00009Ar 1               ;
00009Ar 1               ; Do not use this as an initialized segment if you plan on linking
00009Ar 1               ; this source as a future game cartridge later.  You must COPY any
00009Ar 1               ; read-only data into this address space.
00009Ar 1               ;
00009Ar 1               ; If your data was saved from some tool in binary format, you can
00009Ar 1               ; include that binary file here as:
00009Ar 1               ;		.incbin "udc.bin"
00009Ar 1               ;
00009Ar 1               ; else, just enter each 8x8 values here, such as:
00009Ar 1               ;	.byte	$FF,$81,$81,$81,$81,$81,$81,$FF
00009Ar 1               ; or:
00009Ar 1               ;	.byte	%11111111	; square
00009Ar 1               ;	.byte	%10000001
00009Ar 1               ;	.byte	%10000001
00009Ar 1               ;	.byte	%10000001
00009Ar 1               ;	.byte	%10000001
00009Ar 1               ;	.byte	%10000001
00009Ar 1               ;	.byte	%10000001
00009Ar 1               ;	.byte	%11111111
00009Ar 1               ;
00009Ar 1               ;	.segment "UDC"
00009Ar 1               
00009Ar 1               
