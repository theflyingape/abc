ca65 V2.18 - Fedora 2.19-13.fc43
Main file   : abc.s
Current file: abc.s

000000r 1               ;***********************************************************************
000000r 1               ; VIC 20: Awesome Boot Cartridge
000000r 1               ;   written by Robert Hurst <robert@hurst-ri.us>
000000r 1               ;   updated version: 05-Jan-2016
000000r 1               ;
000000r 1               	.fileopt author, "Robert Hurst"
000000r 1               	.fileopt comment, "VIC 20: Awesome Boot Cartridge"
000000r 1               	.fileopt compiler, "ca65"
000000r 1               	.setcpu "6502"
000000r 1               
000000r 1               	.proc ABC
000000r 1               	.include "abc.h"
000000r 2               ;***********************************************************************
000000r 2               ; VIC 20: Awesome Boot Cartridge
000000r 2               ;   written by Robert Hurst <robert@hurst-ri.us>
000000r 2               ;   updated version: 21-Oct-2015
000000r 2               ;
000000r 2               ; relevant VIC 20 symbols for your program's use or reference
000000r 2               ;
000000r 2               RNDSEED		= $8B		; -$8F: BASIC RND seed value
000000r 2               JIFFYH		= $A0		; jiffy clock high
000000r 2               JIFFYM		= $A1		; jiffy clock med
000000r 2               JIFFYL		= $A2		; jiffy clock low
000000r 2               DATANEXT	= $A6		; DATASETTE pointer (0-191)
000000r 2               KEYCHARS	= $C6		; number of characters in KEYBUF (0-10)
000000r 2               RVSFLAG		= $C7		; character reverse flag
000000r 2               ROWS		= $C8		; current screen row length (16-24)
000000r 2               CURSOR		= $CC		; cursor enable (0=flash)
000000r 2               CRSRCHAR	= $CE		; character under cursor
000000r 2               SCRNLINE	= $D1		; pointer to cursor's screen line
000000r 2               CRSRCOL		= $D3		; position of cursor on screen line
000000r 2               CRSR		= $D4		; programmed cursor (0=direct)
000000r 2               COLS		= $D5		; current screen line length (16-24)
000000r 2               CRSRROW		= $D6		; screen row where cursor is
000000r 2               INSERTS		= $D8		; # of INSERTs outstanding
000000r 2               LINKLINE	= $D9		; -$F0: screen line link table (24-bytes)
000000r 2               SCRTEMP1	= $F1		; dummy screen link
000000r 2               SCRTEMP2	= $F2		; screen row marker
000000r 2               COLORLINE	= $F3		; pointer to cursor's color line
000000r 2               KEYBOARD	= $F5		; keyboard pointer
000000r 2               RECEIVE		= $F7		; serial receive pointer
000000r 2               TRANSMIT	= $F9		; serial transmit pointer
000000r 2               BASICTMP	= $FF		; BASIC storage
000000r 2               INPUT		= $0200		; -$0258: 89-character BASIC INPUT buffer
000000r 2               KEYBUF		= $0277		; -$0280: 10-character keyboard buffer
000000r 2               COLORCODE	= $0286		; current cursor color
000000r 2               CRSRCOLOR	= $0287		; color under cursor
000000r 2               SCRNPAGE	= $0288		; active screen memory page (unexpanded = $1E)
000000r 2               SHIFTMODE	= $0291		; 0=allow, 128=locked
000000r 2               SCROLLFLAG	= $0292		; auto scrolldown flag
000000r 2               TEMPA		= $030C		; temp storage for A register
000000r 2               TEMPX		= $030D		; temp storage for X register
000000r 2               TEMPY		= $030E		; temp storage for Y register
000000r 2               TEMPP		= $030F		; temp storage for P register
000000r 2               VECTORS		= $0310		; -$033B: VIC ROM jump vectors
000000r 2               DATASETTE	= $033C		; -$03FB: 192-byte tape input buffer
000000r 2               RAM0		= $0400		; -$0FFF: 3K expansion
000000r 2               RAM		= $1000		; -$1FFF: internal memory
000000r 2               RAM1		= $2000		; -$3FFF: 8K expansion
000000r 2               RAM2		= $4000		; -$5FFF: 8K expansion
000000r 2               RAM3		= $6000		; -$7FFF: 8K expansion
000000r 2               PET		= $8000		; -$8FFF: 4k character rom
000000r 2               MASK		= $8270		; ROM character $4D: Shift-N (/)
000000r 2               VIC		= $9000		; start of Video Interface Chip registers
000000r 2               CART		= $A000		; -$BFFF: 8K expansion
000000r 2               ; ****	VIC BASIC & KERNAL ROM	****
000000r 2               PRINT		= $CB1E		; print null-terminated string
000000r 2               PRINTUINT	= $DDCD		; print XA as unsigned integer
000000r 2               BASSFT		= $E467		; BASIC warm start
000000r 2               MACHINE		= $EDE4		; NTSC=$05, PAL=$0C
000000r 2               STOPKEY		= $F770		; check for STOP key pressed
000000r 2               RESET		= $FD22		; warm startup
000000r 2               VECTOR		= $FF8D		; read/set vectored I/O
000000r 2               RESTOR		= $FF8A		; restore default I/O vectors
000000r 2               SETMSG		= $FF90		; control KERNAL messages
000000r 2               SECOND		= $FF93		; send secondary address after LISTEN
000000r 2               TKSA		= $FF96		; send secondary address after TALK
000000r 2               MEMTOP		= $FF99		; read/set the top of memory
000000r 2               MEMBOT		= $FF9C		; read/set the bottom of memory
000000r 2               SCNKEY		= $FF9F		; scan keyboard
000000r 2               SETTMO		= $FFA2		; set timeout on serial bus
000000r 2               ACPTR		= $FFA5		; input byte from serial port
000000r 2               CIOUT		= $FFA8		; output byte to serial port
000000r 2               UNTLK		= $FFAB		; command serial bus device to UNTALK
000000r 2               UNLSN		= $FFAE		; command serial bus device to UNLISTEN
000000r 2               LISTEN		= $FFB1		; send LISTEN command
000000r 2               TALK		= $FFB4		; send TALK command
000000r 2               READST		= $FFB7		; read I/O status word
000000r 2               SETLFS		= $FFBA		; set logical, first and second addresses
000000r 2               SETNAM		= $FFBD		; set filename
000000r 2               OPEN		= $FFC0		; open a logical file
000000r 2               CLOSE		= $FFC3		; close a logical file
000000r 2               CHKIN		= $FFC6		; open channel for input
000000r 2               CHKOUT		= $FFC9		; open channel for output
000000r 2               CLRCHN		= $FFCC		; close input and out channels
000000r 2               CHRIN		= $FFCF		; input character from channel
000000r 2               CHROUT		= $FFD2		; output character to channel
000000r 2               LOAD		= $FFD5		; load RAM from a device
000000r 2               SAVE		= $FFD8		; save RAM to device
000000r 2               SETTIM		= $FFDB		; set real time clock
000000r 2               RDTIM		= $FFDE		; read real time clock
000000r 2               STOP		= $FFE1		; scan STOP key
000000r 2               GETIN		= $FFE4		; get a character from keyboard queue
000000r 2               CLALL		= $FFE7		; close all channels and files
000000r 2               UDTIM		= $FFEA		; increment real time clock
000000r 2               SCREEN		= $FFED		; return X,Y organization of screen
000000r 2               PLOT		= $FFF0		; read/set X,Y cursor position
000000r 2               IOBASE		= $FFF3		; returns base address of I/O devices
000000r 2               
000000r 2               
000000r 1               
000000r 1               
000000r 1               ;***********************************************************************
000000r 1               ; Awesome Boot Cartridge: constants
000000r 1               ;
000000r 1               	.segment "CART"
000000r 1               
000000r 1  rr rr        	.word RAM5		; PRG load address off floppy
000002r 1               
000002r 1               	; ROM boot signature
000002r 1  rr rr        RAM5:	.word ABC		; starting address
000004r 1  rr rr        	.word NMI		; RESTORE key address
000006r 1  41 30 C3 C2  A0CBM:	.byte $41, $30, $C3, $C2, $CD
00000Ar 1  CD           
00000Br 1               
00000Br 1               	; floppy disk commands
00000Br 1  55 49 2D     CMDVIC:	.byte "UI-"		; directive for VIC 20 speed
00000Er 1  24 41 42 43  CMDABC: .byte "$ABC"		; directive for access to directory
000012r 1  24 41 55 54  CMDRUN: .byte "$AUTORUN",0	; directive for access to directory
000016r 1  4F 52 55 4E  
00001Ar 1  00           
00001Br 1  24 2A 3D 50  CMDPRG: .byte "$*=P"		; directive for access to directory
00001Fr 1               
00001Fr 1               	; string constants
00001Fr 1  0D 90 53 43  MSG1:	.byte 13,144,"SCANNING DRIVES ...",13,31,0
000023r 1  41 4E 4E 49  
000027r 1  4E 47 20 44  
000037r 1  0D 90 2D 1C  MSG2:	.byte 13,144,"-",28,"ABC FLOPPY NOT FOUND",144,"-",0
00003Br 1  41 42 43 20  
00003Fr 1  46 4C 4F 50  
000052r 1  0D 90 20 12  MSG3:	.byte 13,144," ",18," RESTORE ",146," KEY: RESET",13,0
000056r 1  20 52 45 53  
00005Ar 1  54 4F 52 45  
00006Dr 1  0D 20 9E 12  MSG4:	.byte 13," ",158,18," F1 ",146,31," BASIC ",158,18," F3 ",146,31," +3K",13
000071r 1  20 46 31 20  
000075r 1  92 1F 20 42  
00008Br 1  0D 20 9E 12  	.byte 13," ",158,18," F5 ",146,31," +ANY  ",158,18," F7 ",146,31," SCAN",13,0
00008Fr 1  20 46 35 20  
000093r 1  92 1F 20 2B  
0000ABr 1  92 20 20 20  MSG5:	.byte 146,"   ",157,157,157,0
0000AFr 1  9D 9D 9D 00  
0000B3r 1  0D 90 42 4F  MSG6:	.byte 13,144,"BOOTING ",0
0000B7r 1  4F 54 49 4E  
0000BBr 1  47 20 00     
0000BEr 1               
0000BEr 1               
0000BEr 1               ;***********************************************************************
0000BEr 1               ; RESTORE key was pressed -- make it an ABC warm reset function key
0000BEr 1               ;
0000BEr 1               NMI:
0000BEr 1  A9 FF        	lda #$FF		; acknowledge and clear
0000C0r 1  8D 22 91     	sta $9122		; interrupts
0000C3r 1  AC 11 91     	ldy $9111
0000C6r 1               
0000C6r 1               
0000C6r 1               ;***********************************************************************
0000C6r 1               ; AWESOME BOOT CARTRIDGE: entry point
0000C6r 1               ;
0000C6r 1               ABC:
0000C6r 1               	; initialize VIC Kernal
0000C6r 1  20 8D FD     	jsr $FD8D		; ramtas	Initialize System Constants (memory pointers)
0000C9r 1  20 52 FD     	jsr $FD52		; restor	Restore Kernal vectors (at 0314)
0000CCr 1  20 F9 FD     	jsr $FDF9		; ioinit	Initialize I/O (timers are enabled)
0000CFr 1  20 18 E5     	jsr $E518		; cint1		Initialize I/O (VIC reset, must follow ramtas)
0000D2r 1               
0000D2r 1               	; initialize VIC BASIC
0000D2r 1  20 5B E4     	jsr $E45B		; initv		Initialize vectors
0000D5r 1  20 A4 E3     	jsr $E3A4		; initcz	Initialize BASIC RAM
0000D8r 1               
0000D8r 1  AC 82 02     	ldy $0282
0000DBr 1  C0 10        	cpy #$10
0000DDr 1  90 10        	bcc @welcome		; +3K only detected?
0000DFr 1               	; look for added presence of a 3K memory expander
0000DFr 1  B9 23 03     @fp:	lda $0323,y
0000E2r 1  99 EF 0F     	sta $0fef,y
0000E5r 1  D9 EF 0F     	cmp $0fef,y
0000E8r 1  D0 05        	bne @welcome
0000EAr 1  88           	dey
0000EBr 1  D0 F2        	bne @fp			; reset start of memory to include RAM0, obviously
0000EDr 1  84 2C        	sty $2C			; not for BASIC use, but for banner purposes only
0000EFr 1               
0000EFr 1               	; welcome banner
0000EFr 1               @welcome:
0000EFr 1  A9 01        	lda #1			; just to have some fun:
0000F1r 1  85 C7        	sta RVSFLAG		; - character reverse flag
0000F3r 1  A9 03        	lda #3			; - set color to CYAN
0000F5r 1  8D 86 02     	sta COLORCODE
0000F8r 1  20 04 E4     	jsr $E404		; initms	Output power-up message
0000FBr 1               
0000FBr 1               
0000FBr 1               ;***********************************************************************
0000FBr 1               ; VIC IEC startup
0000FBr 1               ;
0000FBr 1               IEC:
0000FBr 1               	; probe IEC units #11 thru #8 for an ABC program signature
0000FBr 1               	; useful for that uIEC device typically set higher than #8
0000FBr 1  A9 rr        	lda #<MSG1
0000FDr 1  A0 rr        	ldy #>MSG1
0000FFr 1  20 1E CB     	jsr PRINT
000102r 1  A2 0B        	ldx #11
000104r 1  86 BA        	stx $BA			; current device
000106r 1               @scan:
000106r 1  A9 01        	lda #1			; LF: logical file
000108r 1  85 10        	sta $10			; and set flag to print the floppy label
00010Ar 1  A6 BA        	ldx $BA			; IN: device
00010Cr 1  A0 0F        	ldy #15			; SA: secondary address
00010Er 1  20 BA FF     	jsr SETLFS
000111r 1  A9 03        	lda #3			; "UI-"
000113r 1  A2 rr        	ldx #<CMDVIC
000115r 1  A0 rr        	ldy #>CMDVIC
000117r 1  20 BD FF     	jsr SETNAM
00011Ar 1  20 C0 FF     	jsr OPEN
00011Dr 1  B0 1F        	bcs @notopen
00011Fr 1               	; print "#n:"
00011Fr 1  A9 23        	lda #35
000121r 1  20 D2 FF     	jsr CHROUT
000124r 1  A6 BA        	ldx $BA
000126r 1  A9 00        	lda #0
000128r 1  20 CD DD     	jsr PRINTUINT
00012Br 1  A9 3A        	lda #':'
00012Dr 1  20 D2 FF     	jsr CHROUT
000130r 1  20 rr rr     	jsr DEVST		; ok, validate device status
000133r 1  A9 04        	lda #4			; "$ABC", VDrive does not support "$ABC=P"
000135r 1  A2 rr        	ldx #<CMDABC		; SF ticket #587
000137r 1  A0 rr        	ldy #>CMDABC
000139r 1  20 rr rr     	jsr DIRPRG
00013Cr 1  C6 D6        	dec CRSRROW
00013Er 1               @notopen:
00013Er 1  A9 01        	lda #1			; cleanup
000140r 1  20 C3 FF     	jsr CLOSE
000143r 1  20 CC FF     	jsr CLRCHN
000146r 1  A5 AA        	lda $AA			; number of PRG entries found
000148r 1  D0 1D        	bne @passed		; found!
00014Ar 1  A6 D6        	ldx CRSRROW
00014Cr 1  A0 00        	ldy #0
00014Er 1  18           	clc
00014Fr 1  20 F0 FF     	jsr PLOT
000152r 1  CE 86 02     	dec COLORCODE
000155r 1  C6 BA        	dec $BA
000157r 1  A6 BA        	ldx $BA
000159r 1  E0 08        	cpx #8
00015Br 1  B0 A9        	bcs @scan
00015Dr 1               
00015Dr 1               	; error, ABC wants ABC on its floppy too:
00015Dr 1  A9 rr        	lda #<MSG2
00015Fr 1  A0 rr        	ldy #>MSG2
000161r 1  20 1E CB     	jsr PRINT
000164r 1  4C rr rr     	jmp MENU
000167r 1               
000167r 1               @passed:
000167r 1  C6 10        	dec $10
000169r 1  A9 08        	lda #8
00016Br 1  A2 rr        	ldx #<CMDRUN
00016Dr 1  A0 rr        	ldy #>CMDRUN
00016Fr 1  20 rr rr     	jsr DIRPRG
000172r 1  A5 AA        	lda $AA
000174r 1  F0 0D        	beq MENU
000176r 1  A2 rr        	ldx #<(CMDRUN+1)
000178r 1  A0 rr        	ldy #>(CMDRUN+1)
00017Ar 1  86 FD        	stx $FD
00017Cr 1  84 FE        	sty $FE
00017Er 1  A9 00        	lda #0
000180r 1  4C rr rr     	jmp BOOT
000183r 1               
000183r 1               
000183r 1               ;***********************************************************************
000183r 1               ; USER MENU
000183r 1               ;
000183r 1               MENU:
000183r 1  A9 rr        	lda #<MSG3
000185r 1  A0 rr        	ldy #>MSG3
000187r 1  20 1E CB     	jsr PRINT
00018Ar 1               @reload:
00018Ar 1  A9 rr        	lda #<MSG4
00018Cr 1  A0 rr        	ldy #>MSG4
00018Er 1  20 1E CB     	jsr PRINT
000191r 1  20 rr rr     	jsr ALLPRG		; refresh up to (in theory) 224 PRG dir entries
000194r 1  20 rr rr     	jsr SHOW8
000197r 1  20 E4 FF     @getin:	jsr GETIN
00019Ar 1  F0 FB        	beq @getin
00019Cr 1  C9 85        @f1:	cmp #133		; f1 key
00019Er 1  D0 10        	bne @f3
0001A0r 1  A9 10        	lda #$10		; unexpanded
0001A2r 1  8D 82 02     @1e:	sta $0282
0001A5r 1  A9 1E        	lda #$1E
0001A7r 1  8D 84 02     	sta $0284
0001AAr 1  8D 88 02     	sta SCRNPAGE
0001ADr 1  4C 32 FD     @basic:	jmp $FD32		; resume BASIC startup
0001B0r 1  C9 86        @f3:	cmp #134		; f3 key
0001B2r 1  D0 0A        	bne @f5
0001B4r 1  A4 2C        	ldy $2C
0001B6r 1  C0 10        	cpy #$10		; no 3K expansion detected?
0001B8r 1  B0 DD        	bcs @getin
0001BAr 1  A9 04        	lda #$04		; make 3K expanded
0001BCr 1  D0 E4        	bne @1e
0001BEr 1  C9 87        @f5:	cmp #135		; f5 key
0001C0r 1  D0 09        	bne @f7
0001C2r 1  AD 88 02     	lda SCRNPAGE
0001C5r 1  C9 10        	cmp #$10		; no 8K expansion detected?
0001C7r 1  D0 CE        	bne @getin
0001C9r 1  F0 E2        	beq @basic
0001CBr 1  C9 88        @f7:	cmp #136		; f7 key
0001CDr 1  D0 03        	bne @digit
0001CFr 1  4C rr rr     	jmp IEC			; app warm reset
0001D2r 1               @digit:
0001D2r 1  C9 39        	cmp #'8'+1
0001D4r 1  B0 09        	bcs @8
0001D6r 1  C9 31        	cmp #'1'
0001D8r 1  90 05        	bcc @8
0001DAr 1  E9 31        	sbc #'1'
0001DCr 1  4C rr rr     	jmp BOOT
0001DFr 1  A5 AA        @8:	lda $AA
0001E1r 1  F0 A7        	beq @reload
0001E3r 1  A9 0D        	lda #13
0001E5r 1  20 D2 FF     	jsr CHROUT
0001E8r 1  20 rr rr     	jsr SHOW8		; any key
0001EBr 1  4C rr rr     	jmp @getin
0001EEr 1               
0001EEr 1               
0001EEr 1               ;***********************************************************************
0001EEr 1               ; get device status: INPUT#1,A$,B$ into BASIC input buffer
0001EEr 1               ;
0001EEr 1               DEVST:
0001EEr 1  A5 D3        	lda CRSRCOL
0001F0r 1  48           	pha
0001F1r 1  A5 D6        	lda CRSRROW
0001F3r 1  48           	pha
0001F4r 1  A0 01        	ldy #1
0001F6r 1  84 08        	sty $08			; scan flag
0001F8r 1  88           	dey
0001F9r 1  84 0B        	sty $0B			; input buffer pointer
0001FBr 1  F0 1E        	beq @cont
0001FDr 1               @exit:
0001FDr 1  A4 0B        	ldy $0B
0001FFr 1  A2 05        	ldx #5
000201r 1  A9 20        	lda #' '
000203r 1  99 00 02     @pad:	sta $0200,Y
000206r 1  C8           	iny
000207r 1  CA           	dex
000208r 1  D0 F9        	bne @pad
00020Ar 1  A9 00        	lda #0
00020Cr 1  99 00 02     	sta $0200,Y
00020Fr 1  A0 02        	ldy #2
000211r 1  20 1E CB     	jsr PRINT		; print device status
000214r 1  68           	pla
000215r 1  85 D6        	sta CRSRROW
000217r 1  68           	pla
000218r 1  85 D3        	sta CRSRCOL
00021Ar 1  60                   rts
00021Br 1               @cont:
00021Br 1  A2 01        	ldx #1			; LF
00021Dr 1  20 C6 FF     	jsr CHKIN
000220r 1  20 rr rr     @input:	jsr @getbyte
000223r 1  C9 2C        	cmp #','
000225r 1  D0 04        	bne @save
000227r 1  C6 08        	dec $08
000229r 1  D0 D2        	bne @exit
00022Br 1  A4 0B        @save:	ldy $0B
00022Dr 1  99 00 02     	sta $0200,Y
000230r 1  E6 0B        	inc $0B
000232r 1  D0 EC        	bne @input
000234r 1               @getbyte:
000234r 1  20 B7 FF     	jsr READST
000237r 1  D0 03        	bne @end		; read error or end of file
000239r 1  4C CF FF     	jmp CHRIN
00023Cr 1  68           @end:	pla
00023Dr 1  68           	pla
00023Er 1  4C rr rr     	jmp @exit
000241r 1               
000241r 1               
000241r 1               ;***********************************************************************
000241r 1               ; cache the current directory of PRG files
000241r 1               ;
000241r 1               ALLPRG:
000241r 1  A9 04        	lda #4			; "$*=P"
000243r 1  A2 rr        	ldx #<CMDPRG
000245r 1  A0 rr        	ldy #>CMDPRG
000247r 1               DIRPRG:
000247r 1  20 BD FF     	jsr SETNAM
00024Ar 1  A9 02        	lda #2			; LF
00024Cr 1  A6 BA        	ldx $BA
00024Er 1  A0 00        	ldy #0			; secondary address 0 (required for dir)
000250r 1  20 BA FF     	jsr SETLFS
000253r 1               
000253r 1  A0 00        	ldy #0
000255r 1  84 AA        	sty $AA			; number of entries
000257r 1  20 C0 FF     	jsr OPEN
00025Ar 1  B0 7F        	bcs @exit
00025Cr 1               	; reset directory cache
00025Cr 1  AE 81 02     	ldx $0281
00025Fr 1  AC 82 02     	ldy $0282
000262r 1  86 FB        	stx $FB			; start display of PRGs
000264r 1  84 FC        	sty $FC
000266r 1  86 FD        	stx $FD			; heh, $FD can mean floppy disk
000268r 1  84 FE        	sty $FE
00026Ar 1               
00026Ar 1  A2 02        	ldx #2			; LF
00026Cr 1  20 C6 FF     	jsr CHKIN
00026Fr 1               
00026Fr 1  A0 04        	ldy #4			; or 6 if @shred
000271r 1  20 rr rr     @label:	jsr @getbyte
000274r 1  88           	dey
000275r 1  D0 FA        	bne @label
000277r 1               	; floppy label
000277r 1               @shred:	;JSR @getbyte		; skip disk label
000277r 1               	;BNE @shred
000277r 1  A0 01        	ldy #1
000279r 1  84 08        	sty $08			; scan flag
00027Br 1  A9 9D        	lda #157		; cursor left
00027Dr 1  20 D2 FF     	jsr CHROUT
000280r 1  A9 20        	lda #' '		; print a space first
000282r 1  20 D2 FF     	jsr CHROUT
000285r 1  A6 10        @char:	ldx $10
000287r 1  F0 03        	beq @gt
000289r 1  20 D2 FF     	jsr CHROUT
00028Cr 1  20 rr rr     @gt:	jsr @getbyte
00028Fr 1  C9 22        	cmp #34
000291r 1  D0 F2        	bne @char
000293r 1  C6 08        	dec $08
000295r 1  F0 F5        	beq @gt			; continue until end of line
000297r 1  20 rr rr     @eol:	jsr @getbyte
00029Ar 1  D0 FB        	bne @eol
00029Cr 1               	;
00029Cr 1  A0 04        @next:	ldy #4			; skip 4 bytes on all lines
00029Er 1  20 rr rr     @eat:	jsr @getbyte		; get a byte from dir and ignore it
0002A1r 1  88           	dey
0002A2r 1  D0 FA        	bne @eat
0002A4r 1  20 rr rr     @cat:	jsr @getbyte
0002A7r 1  C9 22        	cmp #34
0002A9r 1  D0 F9        	bne @cat
0002ABr 1  A0 00        	ldy #0
0002ADr 1  20 rr rr     @prg:	jsr @getbyte
0002B0r 1  C9 22        	cmp #34
0002B2r 1  F0 05        	beq @save
0002B4r 1  91 FD        	sta ($FD),Y
0002B6r 1  C8           	iny
0002B7r 1  D0 F4        	bne @prg
0002B9r 1  E6 AA        @save:	inc $AA
0002BBr 1  A9 00        	lda #0
0002BDr 1  91 FD        	sta ($FD),Y		; null-terminate
0002BFr 1  C8           	iny
0002C0r 1  98           	tya
0002C1r 1  18           	clc
0002C2r 1  65 FD        	adc $FD
0002C4r 1  90 0B        	bcc @lo
0002C6r 1  E6 FE        	inc $FE
0002C8r 1  85 FD        	sta $FD
0002CAr 1  A9 2E        	lda #'.'		; mark every page as consumed
0002CCr 1  20 D2 FF     	jsr CHROUT
0002CFr 1  D0 C6        	bne @eol
0002D1r 1  85 FD        @lo:	sta $FD
0002D3r 1  20 rr rr     @eol2:	jsr @getbyte
0002D6r 1  D0 FB        	bne @eol2
0002D8r 1  4C rr rr     	jmp @next
0002DBr 1               
0002DBr 1               @exit:
0002DBr 1  A9 02        	lda #2			; LF
0002DDr 1  20 C3 FF     	jsr CLOSE
0002E0r 1  20 CC FF     	jsr CLRCHN
0002E3r 1  A9 0D        	lda #13
0002E5r 1  20 D2 FF     	jsr CHROUT
0002E8r 1  60           	rts
0002E9r 1               
0002E9r 1               @getbyte:
0002E9r 1  20 B7 FF     	jsr READST
0002ECr 1  D0 03        	bne @err		; read error or end of file
0002EEr 1  4C CF FF     	jmp CHRIN
0002F1r 1               @err:
0002F1r 1  68           	pla			; don't return to dir reading loop
0002F2r 1  68           	pla
0002F3r 1  4C rr rr     	jmp @exit
0002F6r 1               
0002F6r 1               
0002F6r 1               ;***********************************************************************
0002F6r 1               ; display next 8 cached PRG files
0002F6r 1               ;
0002F6r 1               SHOW8:
0002F6r 1  A6 FB        	LDX $FB
0002F8r 1  A4 FC        	LDY $FC
0002FAr 1  86 FD        	STX $FD			; save top of displayed items
0002FCr 1  84 FE        	STY $FE			; for potential user selection later
0002FEr 1  A2 00        	LDX #0
000300r 1  8E 0D 03     	STX TEMPX
000303r 1  8E 0E 03     	STX TEMPY
000306r 1               @loop:
000306r 1  AC 0E 03     	LDY TEMPY
000309r 1  C4 AA        	CPY $AA			; number of entries
00030Br 1  B0 46        	BCS @exit
00030Dr 1  A9 12        	LDA #18
00030Fr 1  20 D2 FF     	JSR CHROUT
000312r 1  AD 86 02     	LDA COLORCODE
000315r 1  49 02        	EOR #2
000317r 1  8D 86 02     	STA COLORCODE
00031Ar 1  AD 0D 03     	LDA TEMPX
00031Dr 1  18           	CLC
00031Er 1  69 31        	ADC #'1'
000320r 1  20 D2 FF     	JSR CHROUT
000323r 1  A9 92        	LDA #146
000325r 1  20 D2 FF     	JSR CHROUT
000328r 1  A9 20        	LDA #' '
00032Ar 1  20 D2 FF     	JSR CHROUT
00032Dr 1  A5 FB        	LDA $FB
00032Fr 1  A4 FC        	LDY $FC
000331r 1  20 1E CB     	JSR PRINT
000334r 1  A6 D3        	LDX CRSRCOL
000336r 1  CA           	DEX
000337r 1  8A           	TXA
000338r 1  18           	CLC
000339r 1  65 FB        	ADC $FB
00033Br 1  90 02        	BCC @lo
00033Dr 1  E6 FC        	INC $FC
00033Fr 1  85 FB        @lo:	STA $FB
000341r 1  A9 0D        	LDA #13
000343r 1  20 D2 FF     	JSR CHROUT
000346r 1  EE 0E 03     	INC TEMPY
000349r 1  EE 0D 03     	INC TEMPX
00034Cr 1  AE 0D 03     	LDX TEMPX
00034Fr 1  E0 08        	CPX #8
000351r 1  D0 B3        	BNE @loop
000353r 1               @exit:
000353r 1  A2 00        	LDX #0
000355r 1  A5 AA        	LDA $AA
000357r 1  C9 08        	CMP #8
000359r 1  90 03        	BCC @nomore
00035Br 1  E9 08        	SBC #8
00035Dr 1  AA           	TAX
00035Er 1               @nomore:
00035Er 1  86 AA        	STX $AA
000360r 1  60           	RTS
000361r 1               
000361r 1               
000361r 1               ;***********************************************************************
000361r 1               ; boot the selected file using intellisense for VIC 20 memory config
000361r 1               ;
000361r 1               BOOT:
000361r 1  A0 00        	LDY #0
000363r 1  AA           	TAX
000364r 1  F0 09        	BEQ @gotit
000366r 1  C8           @next:	INY			; assume at least 1-character filename
000367r 1  B1 FD        	LDA ($FD),Y
000369r 1  D0 FB        	BNE @next
00036Br 1  CA           	DEX
00036Cr 1  D0 F8        	BNE @next
00036Er 1  C8           	INY			; offset into directory cache
00036Fr 1               @gotit:
00036Fr 1  98           	TYA
000370r 1  18           	CLC
000371r 1  65 FD        	ADC $FD
000373r 1  90 02        	BCC @lo
000375r 1  E6 FE        	INC $FE
000377r 1  85 FD        @lo:	STA $FD
000379r 1  A0 00        	LDY #0
00037Br 1  C8           @len:	INY			; assume at least 1-character filename
00037Cr 1  B1 FD        	LDA ($FD),Y
00037Er 1  D0 FB        	BNE @len
000380r 1  84 B7        	STY $B7			; filename length
000382r 1               @entry:
000382r 1  A9 rr        	lda #<MSG6
000384r 1  A0 rr        	ldy #>MSG6
000386r 1  20 1E CB     	jsr PRINT		; booting ...
000389r 1  A5 FD        	lda $FD
00038Br 1  A4 FE        	ldy $FE
00038Dr 1  20 1E CB     	jsr PRINT
000390r 1  A9 01        	lda #1			; LF
000392r 1  A6 BA        	ldx $BA			; last device
000394r 1  A0 00        	ldy #0			; SA: 0=ignore, 1=use header address
000396r 1  20 BA FF     	jsr SETLFS
000399r 1  A5 B7        	lda $B7
00039Br 1  A6 FD        	ldx $FD
00039Dr 1  A4 FE        	ldy $FE
00039Fr 1  20 BD FF     	jsr SETNAM
0003A2r 1               
0003A2r 1               	; PRG intellisense (ha!)
0003A2r 1  20 C0 FF     	jsr OPEN
0003A5r 1  90 03        	bcc @use
0003A7r 1  4C rr rr     	jmp MENU
0003AAr 1  A2 01        @use:	ldx #1			; LF
0003ACr 1  20 C6 FF     	jsr CHKIN
0003AFr 1               
0003AFr 1  20 rr rr     	jsr @getbyte
0003B2r 1  85 AE        	sta $AE
0003B4r 1  C9 02        	cmp #2			; load address low
0003B6r 1  90 03        	bcc @hi
0003B8r 1  4C 22 FD     	jmp RESET
0003BBr 1  20 rr rr     @hi:	jsr @getbyte
0003BEr 1  85 AF        	sta $AF
0003C0r 1  A5 AE        	lda $AE
0003C2r 1  D0 0A        	bne @exit
0003C4r 1  20 rr rr     	jsr @getbyte
0003C7r 1  C9 00        	cmp #0
0003C9r 1  F0 03        	beq @exit
0003CBr 1  4C 22 FD     	jmp RESET
0003CEr 1               
0003CEr 1               @exit:
0003CEr 1  A9 01        	lda #1			; LF
0003D0r 1  20 C3 FF     	jsr CLOSE
0003D3r 1               	;JSR CLRCHN
0003D3r 1  A5 AF        	lda $AF
0003D5r 1  C9 04        	cmp #4			; +3k
0003D7r 1  F0 04        	beq @VIC
0003D9r 1  C9 10        	cmp #$10
0003DBr 1  D0 0B        	bne @BASIC		; powered up in 8K+ mode already
0003DDr 1               
0003DDr 1               @VIC:
0003DDr 1  8D 82 02     	sta $0282
0003E0r 1  A9 1E        	lda #$1E
0003E2r 1  8D 84 02     	sta $0284
0003E5r 1  8D 88 02     	sta SCRNPAGE
0003E8r 1               
0003E8r 1               @BASIC:	; initialize for BASIC
0003E8r 1  20 18 E5     	jsr $E518		; cint1		Initialize I/O (VIC reset, must follow ramtas)
0003EBr 1  20 5B E4     	jsr $E45B		; initv		Initialize vectors
0003EEr 1  20 A4 E3     	jsr $E3A4		; initcz	Initialize BASIC RAM
0003F1r 1  20 04 E4     	jsr $E404		; initms	Output power-up message
0003F4r 1               
0003F4r 1               	; LOAD program selection
0003F4r 1               	;JSR $C644		; forced NEW
0003F4r 1  A9 80        	lda #$80		; turn on kernal messages
0003F6r 1  20 90 FF     	jsr SETMSG
0003F9r 1  A9 00        	lda #0			; 0=LOAD, 1=VERIFY
0003FBr 1  A6 2B        	ldx $2B			; get start of memory low byte
0003FDr 1  A4 2C        	ldy $2C			; get start of memory high byte
0003FFr 1  20 D5 FF     	jsr LOAD
000402r 1  86 2D        	stx $2D			; set start of variables low byte
000404r 1  84 2E        	sty $2E			; set start of variables high byte
000406r 1               
000406r 1               	; RUN
000406r 1               	;JSR $C660		; CLR
000406r 1  20 59 C6     	jsr $C659		; reset execution to start, clear variables and flush stack
000409r 1  4C AE C7     	jmp $C7AE		; goto BASIC
00040Cr 1               
00040Cr 1               @getbyte:
00040Cr 1  20 B7 FF     	jsr READST
00040Fr 1  D0 03        	bne @err		; read error or end of file
000411r 1  4C CF FF     	jmp CHRIN
000414r 1               @err:
000414r 1  68           	pla			; don't return to dir reading loop
000415r 1  68           	pla
000416r 1  4C rr rr     	jmp @exit
000419r 1               
000419r 1               	.endproc
000419r 1               
000419r 1               
